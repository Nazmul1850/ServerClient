
%x CHARSTATE
%x STRINGSTATE
%x MULTICOMENT
%x SINGLECOMMENT
%x FINISH


%{

#include "includes.h"

ofstream fout("1705115_log.txt");
ofstream foutToken("1705115_token.txt");
extern ofstream lout;
extern ofstream eout;

#include "SymbolInfo.h"
#include "ScopeTable.h"
#include "SymbolTable.h"

// #define YYSTYPE SymbolInfo*

#include "y.tab.h"

extern YYSTYPE yylval;
extern SymbolTable *table;
void yyerror(char *);

int lineCount=1;
int errorCount = 0;
int tempLine = 0;
string currentString = "";
string fileString = "";
bool readMore = false;
bool commentFlag = false;
bool unfinish = false;


void handleID(string id) {
    fout<<endl;
    fout<<"Line no "<<lineCount<<": Token <ID> Lexeme "<<id<<" found"<<endl;
    foutToken<<"<ID, "<<id<<"> ";
}
void handleKeyword(string key) {
    string temp = key;
    transform(temp.begin(), temp.end(), temp.begin(), ::toupper);
    fout<<endl;
    fout<<"Line no "<<lineCount<<": Token <"<<temp<<"> Lexeme "<<key<<" found"<<endl;
    foutToken<<"<"<<temp<<"> ";
  
}
void handleOperator(string op) {
    if (op == "++") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <INCOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<INCOP, "<<op<<"> ";
    }
    else if(op == "--") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <INCOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<DECOP, "<<op<<"> ";
    }
    else if(op == "+") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <ADDOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<ADDOP, "<<op<<"> ";
    }
    else if(op == "-") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <ADDOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<ADDOP, "<<op<<"> ";
    }
    else if(op == "*") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <MULOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<MULOP, "<<op<<"> ";
    }
    else if(op == "/") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <MULOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<MULOP, "<<op<<"> ";
    }
    else if(op == "%") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <MULOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<MULOP, "<<op<<"> ";
    }
    else if(op == "<") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == "<=") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == ">") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == ">=") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == "==") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == "!=") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RELOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RELOP, "<<op<<"> ";
    }
    else if(op == "=") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <ASSIGNOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<ASSIGNOP, "<<op<<"> ";
    }
    else if(op == "&&") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <LOGICOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<LOGICOP, "<<op<<"> ";
    }
    else if(op == "||") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <LOGICOP> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<LOGICOP, "<<op<<"> ";
    }
    else if(op == "!") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <NOT> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<NOT, "<<op<<"> ";
    }
    else if(op == "(") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <LPAREN> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<LPAREN, "<<op<<"> ";
    }
    else if(op == ")") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RPAREN> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RPAREN, "<<op<<"> ";
    }
    else if(op == "{") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <LCURL> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<LCURL, "<<op<<"> ";
    }
    else if(op == "}") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RCURL> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RCURL, "<<op<<"> ";
    }
    else if(op == "[") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <LTHIRD> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<LTHIRD, "<<op<<"> ";
    }
    else if(op == "]") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <RTHIRD> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<RTHIRD, "<<op<<"> ";
    }
    else if(op == ",") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <COMMA> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<COMMA, "<<op<<"> ";
    }
    else if(op == ";") {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <SEMICOLON> Lexeme "<<op<<" found"<<endl;
        foutToken<<"<SEMICOLON, "<<op<<"> ";
    }
}

void handleFloat(string fnum) {
    fout<<endl;
    fout<<"Line no "<<lineCount<<": Token <CONST_FLOAT> Lexeme "<<fnum<<" found"<<endl;
    foutToken<<"<CONST_FLOAT, "<<fnum<<"> ";
}

void handleDecimalError(string key) {
    errorCount++;
    fout<<endl;
    fout<<"Error at line no "<<lineCount<<": Too many decimal points "<<key<<endl;
}
void handleIllFormedError(string key) {
    errorCount++;
    fout<<endl;
    fout<<"Error at line no "<<lineCount<<": Ill formed number "<<key<<endl;
}

void handleInt(string num) {
    fout<<endl;
    fout<<"Line no "<<lineCount<<": Token <CONST_INT> Lexeme "<<num<<" found"<<endl;
    foutToken<<"<CONST_INT, "<<num<<"> ";
}
void concatChar(string key) {
    currentString += key;
}
void handleChar(string key) {
    if (key[1] == '\\' && key[2] == '\'') {
            fout<<endl;
            errorCount++;
            fout<<"Error at line no "<<lineCount<<": Unterminated character "<<key<<endl;
            return;
        }
    if (key[1] == '\\' && key.length()==4) {
        if (key[3] == '\'') {
            if (key[2] == 'n'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \n>"<<endl;
                lineCount++;
                foutToken<<"<CONST_CHAR, \n> ";
            }
            else if(key[2] == 't') {
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \t>"<<endl;
                foutToken<<"<CONST_CHAR, \t> ";
            }
            else if(key[2] == '\\') {
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \\>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == '\''){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \'>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == 'a'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \a>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == 'f'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \f>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == 'r'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \r>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == 'v'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \v>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
            else if(key[2] == '0'){
                fout<<endl;
                fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> "<<"<CONST_CHAR, \0>"<<endl;
                foutToken<<"<CONST_CHAR, "<<key<<"> ";
            }
        }
        
    }
    else if(key[2] == '\'') {
        fout<<endl;
        fout<<"Line no "<<lineCount<<": Token <CONST_CHAR> Lexeme "<<key<<" found --> <CONST_CHAR, "<<key[1]<<">"<<endl;
        foutToken<<"<CONST_CHAR, "<<key[1]<<"> ";
    }
    else if(key[key.length()-1] == '\'') {
            if(key[1] == '\'') {
            errorCount++;
            fout<<endl;
            fout<<"Error at line no "<<lineCount<<": Empty character constant error "<<key<<endl;
            }
            else {
            errorCount++;
            fout<<endl;
            fout<<"Error at line no "<<lineCount<<": Multi character constant error "<<key<<endl;
            }
    }
    else if(key[key.length()-1] == '\n' ){
            errorCount++;
            fout<<endl;
            fout<<"Error at line no "<<lineCount<<": Unterminated character "<<key<<endl;
            lineCount++;
    }
}
void handleString(string str) {
        currentString += str;      
}
void finishString() {
    fileString = "";
    currentString = "";
}
void handleFileString() {
    for(int i=0;i<currentString.length()-1;i++) {
        if(currentString[i] == '\\') {
            if (currentString[i+1] == '"') {
                fileString += "\"";
            }
            else if(currentString[i+1] == '\'') {
                fileString += "\'";
            }
            else if(currentString[i+1] == '\n') {

            }
            else if(currentString[i+1] == 'n') {
                fileString += "\n";
                lineCount++;
            }
            else if(currentString[i+1] == 't') {
                fileString += "\t";
            }
            else if(currentString[i+1] == '\\') {
                fileString += "\\";
            }
            else if(currentString[i+1] == 'a') {
                fileString += "\a";
            }
            else if(currentString[i+1] == 'f') {
                fileString += "\f";
            }
            else if(currentString[i+1] == '\r') {
                fileString += "\r";
            }
            else if(currentString[i+1] == '\b') {
                fileString += "\b";
            }
            else if(currentString[i+1] == '\v') {
                fileString += "\v";
            }
            else if(currentString[i+1] == '\0') {
                fileString += '\0';
            }
            else {
                fileString += currentString[i+1];
            }
            i++;
        }
        else {
            fileString += currentString[i];
        }
    }
    fileString += currentString[currentString.length()-1];
    fout<<"Line no "<<tempLine<<": Token <STRING> Lexeme "<<currentString<<" found --> <STRING, "<<fileString<<">"<<endl;
    foutToken<<"<STRING, "<<fileString<<"> ";

}
void handleMultiComment(string str) {
    currentString += str;
}
void multiComentWrite() {
    fout<<"Line no "<<tempLine<<": Token <COMMENT> Lexeme /*"<<currentString<<"*/ found"<<endl;
    currentString = "";
}

void handleSingleComment(string str) {
    commentFlag = false;
    for(int i=0;i<str.length();i++) {
        if(str[i] == '\\') {
            if(i == str.length()-1) {
                commentFlag = true;
            }
        }
    }
    currentString += str;
    if(commentFlag) {
            currentString += "\n";
            lineCount++;
        };
}
void singleComentWrite() {
    fout<<": Token <COMMENT> Lexeme //"<<currentString<<" found"<<endl;
    currentString = "";
}

%}



AlphaNumeric [a-zA-Z0-9_]

%%


[ \t] {}
[\n] {
    lineCount++; 
    }

"int" {handleKeyword(yytext); return INT;}
"char" {handleKeyword(yytext); return CHAR;}
"float" {handleKeyword(yytext); return FLOAT;}
"double" {handleKeyword(yytext); return DOUBLE;}
"void" {handleKeyword(yytext); return VOID;}
"if" {handleKeyword(yytext); return IF;}
"else" {handleKeyword(yytext); return ELSE;}
"for" {handleKeyword(yytext); return FOR;}
"while" {handleKeyword(yytext); return WHILE;}
"do" {handleKeyword(yytext); return DO;}
"return" {handleKeyword(yytext); return RETURN;}
"switch" {handleKeyword(yytext); return SWITCH;}
"case" {handleKeyword(yytext); return CASE;}
"default" {handleKeyword(yytext); return DEFAULT;}
"continue" {handleKeyword(yytext); return CONTINUE;}



"+"   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("+","ADDOP");
        return ADDOP;
        }
"-"   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("-","ADDOP");
        return ADDOP;
        }
"*"   { handleOperator(yytext);
        yylval.si = new SymbolInfo("*","MULOP");
        return MULOP;}
"/"   { handleOperator(yytext);
        yylval.si = new SymbolInfo("/","MULOP");
        return MULOP;}
"%"   { handleOperator(yytext);
        yylval.si = new SymbolInfo("%","MULOP");
        return MULOP;}
"++"   {handleOperator(yytext); return INCOP;}
"--"   {handleOperator(yytext); return DECOP;}
"<"   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("<","RELOP");
        return RELOP;}
"<="   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("<=","RELOP");
        return RELOP;}
">"   { handleOperator(yytext); 
        yylval.si = new SymbolInfo(">","RELOP");
        return RELOP;}
">="   { handleOperator(yytext); 
        yylval.si = new SymbolInfo(">=","RELOP");
        return RELOP;}
"=="   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("==","RELOP");
        return RELOP;}
"!="   { handleOperator(yytext); 
        yylval.si = new SymbolInfo("!=","RELOP");
        return RELOP;}
"="   {handleOperator(yytext); return ASSIGNOP;}
"&&"   {handleOperator(yytext); 
        yylval.si = new SymbolInfo("&&","LOGICOP");
        return LOGICOP;}
"||"   {handleOperator(yytext); 
        yylval.si = new SymbolInfo("||","LOGICOP");
        return LOGICOP;}
"!"   {handleOperator(yytext); return NOT;}
"("   {handleOperator(yytext); return LPAREN;}
")"   {handleOperator(yytext); return RPAREN;}
"{"   {handleOperator(yytext); return LCURL;}
"}"   {handleOperator(yytext); return RCURL;}
"["   {handleOperator(yytext); return LTHIRD;}
"]"   {handleOperator(yytext); return RTHIRD;}
";"   {handleOperator(yytext); return SEMICOLON;}
","   {handleOperator(yytext); return COMMA;}
"printf" {return PRINTLN;}


[0-9]*[\.][0-9]+ {handleFloat(yytext);
                yylval.si = new SymbolInfo(yytext,"CONST_FLOAT");
                return CONST_FLOAT;
             }

([0-9]*[\.][0-9]*)+ {handleDecimalError(yytext);}

[0-9]*[\.]?[0-9]+[E][-]?([0-9]*[\.]+[0-9]*)+ {handleIllFormedError(yytext);}

[0-9]*[\.][0-9]+[E][-]?[0-9]+ {handleFloat(yytext);
                yylval.si = new SymbolInfo(yytext,"CONST_FLOAT");
                return CONST_FLOAT;
             }

[0-9][0-9]* {handleInt(yytext);
             yylval.si = new SymbolInfo(yytext,"CONST_INT");
             return CONST_INT;
             }

[\47] {
    currentString = "";
    BEGIN CHARSTATE;
    concatChar(yytext);
 }
<CHARSTATE>[\40-\46\48-\176] {concatChar(yytext);}
<CHARSTATE>[\n] {
    BEGIN INITIAL;
    concatChar(yytext);
    handleChar(currentString);
    currentString = "";
    }
<CHARSTATE>[\47] {
    BEGIN INITIAL;
    concatChar(yytext);
    handleChar(currentString);
    currentString = "";
}

[\42] {
        BEGIN STRINGSTATE;
        currentString = "";
        tempLine = lineCount;
        fout<<endl;
        handleString(yytext);
    }

<STRINGSTATE>(\134\n) {
    lineCount++;
    handleString(yytext);
    }

<STRINGSTATE>[\n] {
        BEGIN INITIAL;
        errorCount++;
        fout<<endl;
        fout<<"Error at line no "<<tempLine<<": Unterminated String "<<currentString<<endl;
        lineCount++;
        tempLine = 0;
        finishString();
    }

<STRINGSTATE>(\134\42) {handleString(yytext);}
<STRINGSTATE>[\40-\41\43-\176] {
        handleString(yytext);
    } 
<STRINGSTATE>[\42] {
            BEGIN INITIAL;
            handleString(yytext);
            handleFileString();
            tempLine = 0;
            finishString();
            
        }
(\57\52) {
        BEGIN MULTICOMENT;
        fout<<endl;
        tempLine = lineCount;
    }
<MULTICOMENT><<EOF>> {
        BEGIN INITIAL;
        errorCount++;
        fout<<endl;
        fout<<"Error at line no "<<tempLine<<": Unterminated comment /*"<<currentString<<endl;
        tempLine = 0;
    }
<MULTICOMENT>[\n] {
        lineCount++;
        handleMultiComment("\n\t");
    }
<MULTICOMENT>(\52\57) {
        BEGIN INITIAL;
        multiComentWrite();
        tempLine = 0;
    }
<MULTICOMENT>[\40-\176] {
    handleMultiComment(yytext);
    }
(\57\57) {
        BEGIN SINGLECOMMENT;
        fout<<"Line no "<<lineCount;
        currentString = "";
    }
<SINGLECOMMENT>[\40-\176]+ {
        handleSingleComment(yytext);
        if (!commentFlag) {
            BEGIN INITIAL;
            singleComentWrite();
        }
    }

([0-9]+[\.]*?)([a-zA-Z_]+) {
        errorCount++;
        fout<<endl;
        fout<<"Error at line no "<<lineCount<<": Invalid prefix on ID or invalid suffix on Number "<<yytext<<endl;
    }

{AlphaNumeric}+ {
    handleID(yytext);
    SymbolInfo* s= new SymbolInfo(yytext, "ID");
	yylval.si = s;
	return ID;
    }
. {
    errorCount++;
    fout<<endl;
    fout<<"Error at line no "<<lineCount<<": Unrecognized character"<<lineCount<<endl;
  }


%%

int yywrap(void)
{
	return 1;
}






